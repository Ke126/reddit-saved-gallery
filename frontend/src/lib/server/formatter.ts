import type { RedditCard, RedditThing } from '$lib/types/reddit';

const FORMATS = ['png', 'jpg', 'jpeg', 'gif'].map((format) => new RegExp(`\\.${format}`, 'i'));

function isImageLink(input: string): boolean {
	return FORMATS.some((format) => format.test(input));
}

export function formatter(post: RedditThing): RedditCard {
	try {
		// check based on post kind first
		// comments
		if (post.kind === 't1') {
			const obj: RedditCard = {
				_id: post._id,
				pinned: post.pinned,
				subreddit: post.data.subreddit,
				title: post.data.link_title,
				selftext: post.data.body,
				permalink: post.data.permalink,
				media: undefined,
				author: post.data.author,
				link_author: post.data.link_author,
				num_comments: post.data.num_comments,
				score: post.data.score,
				created: post.data.created
			};
			if (post.data.media_metadata) {
				const firstPage = Object.keys(post.data.media_metadata)[0];
				obj.media = {
					type: 'image',
					from: 'media_metadata',
					link: post.data.media_metadata[firstPage].s.u,
					width: post.data.media_metadata[firstPage].s.x,
					height: post.data.media_metadata[firstPage].s.y
				};
			}
			return obj;
		}
		const obj: RedditCard = {
			_id: post._id,
			pinned: post.pinned,
			subreddit: post.data.subreddit,
			title: post.data.title,
			selftext: post.data.selftext,
			permalink: post.data.permalink,
			media: undefined,
			author: post.data.author,
			link_author: undefined,
			num_comments: post.data.num_comments,
			score: post.data.score,
			created: post.data.created
		};

		// links only
		// check for an existing preview generated by reddit
		if (post.data.preview && post.data.preview.images.length > 0) {
			// using original url allows gifs to be displayed with their correct size
			const isUrlImage = post.data.domain === 'i.redd.it' || isImageLink(post.data.url);
			obj.media = {
				type: 'image',
				from: isUrlImage ? 'url, size from preview' : 'preview',
				link: isUrlImage ? post.data.url : post.data.preview.images[0].source.url,
				width: post.data.preview.images[0].source.width,
				height: post.data.preview.images[0].source.height
			};
			return obj;
		}
		// try media_metadata
		if (post.data.media_metadata) {
			// first page is found from order of gallery_data
			let firstPage: string;
			if (post.data.gallery_data && post.data.gallery_data.items.length > 0) {
				firstPage = post.data.gallery_data.items[0].media_id;
			}
			// first page is chosen arbitrarily
			else {
				firstPage = Object.keys(post.data.media_metadata)[0];
			}
			obj.media = {
				type: 'image',
				from: 'media_metadata',
				link: post.data.media_metadata[firstPage].s.u,
				width: post.data.media_metadata[firstPage].s.x,
				height: post.data.media_metadata[firstPage].s.y
			};
			return obj;
		}
		// use low-res thumbnail
		if (isImageLink(post.data.thumbnail)) {
			obj.media = {
				type: 'image',
				from: 'thumbnail',
				link: post.data.thumbnail,
				width: post.data.thumbnail_width,
				height: post.data.thumbnail_height
			};
			return obj;
		}
		// url is already an image, size is unknown
		if (post.data.domain === 'i.redd.it' || isImageLink(post.data.url)) {
			obj.media = {
				type: 'image',
				from: 'url',
				link: post.data.url,
				width: 0,
				height: 0
			};
			return obj;
		}
		// no image was found
		return obj;
	} catch {
		// if there is somehow an error in parsing, return a fallback post
		console.log(`Unknown error in parsing post ${post._id}`);
		return {
			_id: 'fallback',
			pinned: false,
			subreddit: '[unknown]',
			title: 'There was an error in parsing this post',
			selftext: '',
			permalink: '/',
			author: '[unknown]',
			num_comments: 0,
			score: 0,
			created: 0
		};
	}
}
